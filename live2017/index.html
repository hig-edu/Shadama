<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Shadama: A Particle Simulation Programming Environment for Everyone</title>
    <link rel="stylesheet" href="tufte.css"/>
    <link rel="stylesheet" href="latex.css"/>
    <link rel="stylesheet" href="style.css"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <script>
var shadamaEvents = [
    [`Our first example of Shadama is a simple physics simulation of particles and gravity.`, 0],
    [`As in the LOGO programming language, we refer to mobile objects as turtles. Here, we
      declare a breed of turtle such that each turtle will have properties
      "x", "y", "r", "g", "b" and "a".`, 5],
    [`A method is defined with the keyword "def". Methods are executed on
each turtle in a breed. Here, we've defined the "setColor" method to use the turtle's x and y
coordinates to assign them a red and green value.`, 15],
    [`In the static function "setup", we set the number of
turtles in the breed to be 3,000 and then set all turtle's x and y coordinates to be a
random number between 0 and 512. We run "setup" by hitting Cmd-S.`, 27],
    [`Those dots may be hard to see, but we can increase the number of turtles
to 30,000, 300,000 or 1 million.`, 38],
    [`What we want to do next is to move those turtles around. So we define
a method called "move". Move increments the x and y of the turtles. We call
the move method from a static function "step".`, 47],
    [`When we click the "step" clock, "step" is repeatedly executed and the turtles move.`, 58],
    [`Interestingly, while they are moving, we can edit the program on the
fly and the changes take effect as soon as we hit Cmd-S. We can add an
argument to "move", use it in the code, change the call site and the
turtles that went off screen come back.`, 63],
    [`We could even allow each individual turtle to have its own
velocity. So let's add properties "dx" and "dy" to each turtle. Then, we use them in
"move". Here, instead of "n", we increment the "x" and "y" of each turtle
according to their "dx" and "dy".`, 87],
    [`We call the primitive "fillRandom" to set the "dx" and "dy" to be the x and y components
of a randomly-chosen direction vector. Now, all turtles move
in their own individual directions.`, 104],
    [`Let's run it again by executing "setup" manually.`, 116],
    [`Now we'll change this to be a simple gravity simulation. To do so, we add constant
acceleration to the "y" component of the velocity.  Now all turtles are
accelerating toward the bottom.`, 122],
    [`We don't want those particles to go out of bounds. So we modify
the "move" method. First we store "dx" and "dy", as well as the possible
new location of "x" and "y" into local variables.`, 133],
    [`When "newX" is out of bounds, we make the turtle bounce back.`, 143],
    [`When "newY" is out of bounds below, we wrap the value around to the top.`, 149],
    [`After adjusting those variables,
we write the values back to the turtle's properties. Now one million
turtles are falling down, bouncing off the side walls, and wrapping around
to the top.`, 157],
    [`We are now going to create a simulation with large objects. To do so, we use what's called a "patch". A
patch is a 2D grid of cells where turtles can store values. Here,
we create a patch called "Field", and add "r", "g", "b", and "a" properties for each cell.`, 173],
    [`And, we define a breed called "Filler" that operates on the Field.`, 191],
    [`Now we define a method called "fill". The argument for this method is the patch, and
turtles executing this method update the patch cell value at their x and y coordinates.`, 197],
    [`We modify "setup" to use a primitive called
"fillSpace", which creates turtles of the Filler breed and
places them at all integral grid points. When this "setup" is called,
and the "fill" method is called, each "r" and "g" of the patch get values derived from its position, resulting
in this color gradient.`, 208],
    [`Let's make some shapes now. We define
the "fillCircle" method to replace "fill". Let's also add the "clear" method, which clears the field's values.`, 225],
    [`"fillCircle" works by having each Filler turtle
check whether it is within the radius of the circle. If it is, it writes
the value into their corresponding cell.`, 238],
    [`In the "setup" function, we call "fillCircle" and get a circle at (100, 100).`, 256],
    [`Shadama programs can also be interactive. Let's split the "setup" function and
create another one called "loop".`, 265],
    [`Notice to the right that there is a variable
called "mousemove", which changes its value as we move the mouse pointer in the
display. That is an indication that we can use the value in our
program.`, 280],
    [`Now let's tie it all together. This code has methods we used
previously, such as "setColor". "fillCircle" is slightly modified so that
it sets normal vectors for the circle in the patch.`, 297],
    [`In the "move"
method, each turtle checks the normal in the patch cell where the turtle is
located and computes a new direction from the dot product with the normal. When we run
this, particles bounce off the circle and make a beautiful pattern.`, 309],
    [`However, it is a bit hard to see because the colors of the turtles are too
similar. Here, we change the "setColor" method so that instead of using "x"
and "y" position, we use the velocity "dx" and "dy" to determine the turtles'
color.`, 336],
    [`Then we call "setColor" from "loop", so that the colors are updated continuously.`, 349],
    [`Here, horizontal velocity corresponds with reddish color, and vertical
velocity corresponds with greenish color. The visualization can be quickly adjusted
to match how you prefer to view the simulation.`, 354],
    [`For fun, you can make two circles that move symmetrically.`, 364],
    [`Here's an interesting variation of our program. Instead of modeling gravity as pulling downward, gravity follows
the inverse square law in relation to the mouse pointer location. It looks like
there are large structures, but it's actually just a
quarter million particles from regular initial positions, all following the inverse square law.`, 373],
    [`Shadama allows the user to import images. The built-in "fillImage"
takes an image object, creates enough turtles to cover it, and sets the turtle colors
based on the image's pixel values. This looks like an image but it is
actually a bunch of turtles.`, 411],
    [`We reuse our previous "move" method, set the
direction vectors randomly, create the "loop" method that calls "move", and run "loop".`, 431],
    [`For fun,
We can use the turtles' red and green values to determine turtle velocity, causing an
an interesting effect.`, 455],
    [`Let's use those pixels in our gravity simulation.`, 477],
    [`The code checks the timer, and every 10 seconds, it gathers all turtles to their original position.`, 489],
    [`We can also try some mathematical functions. This is a program to
visualize the Mandelbrot set. Notice how we can change the color scheme on the
fly.`, 500],
    [`This is Conway's Game of Life.`, 520],
    [`Again, we can change the program while
the simulation is running, and the code change is reflected in the
simulation right away, without needing to restart.`, 525]];
    </script>
    <script>
       var eventDivs; // [[div, time]]

       var transcript;
       var interval;
       var caption;
       var scroller;

       function processOne(event) {
           var p = document.createElement("div");
           p.innerHTML = "<p class='caption'>" + event[0] + "</p>";
           caption.appendChild(p);
           return [p, event[1]];
       }

       /* YouTube Javascript API stuff */
       var tag = document.createElement('script');
       tag.src = 'https://www.youtube.com/iframe_api';
       var firstScriptTag = document.getElementsByTagName('script')[0];
       firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
       var player;
       function onYouTubeIframeAPIReady() {
           player = new YT.Player('player', {
               height: '576',
               width:  '1024',
               videoId: 'R81egpgDzbY',
               events: { 'onStateChange': onPlayerStateChange },
               playerVars: {rel: 0, showinfo: 0},
           });
       }
       function onPlayerStateChange(e) {
           if (e.data == YT.PlayerState.PLAYING) {
               interval = window.setInterval(updateEventHighlight, 500); // update every half-second
               updateEventHighlight();
           }
           if (e.data == YT.PlayerState.ENDED  ||
               e.data == YT.PlayerState.PAUSED ||
               e.data == YT.PlayerState.BUFFERING) {
               window.clearInterval(interval);
           }
       }

       function findEvent(time, events) {
         for (var i = 0; i < events.length - 1; i++) {
             var pair = events[i];
             var next = events[i+1];
             if (pair[1] <= time && time < next[1]) {
                 return pair[0];
             }
         }
         var pair = events[events.length -1];
         if (pair[1] < time) {
             return pair[0];
         }
       }


       function smoothScrollTo(top, start, duration) {
           cancelAnimationFrame(scroller);
           var current = caption.scrollTop;
           if (current !== top) {
               var t = Date.now() - start;
               if (t >= duration) {
                   caption.scrollTop = top;
               } else {
                   caption.scrollTop = current + t / duration * (top - current);
                   scroller = requestAnimationFrame(function() {smoothScrollTo(top, start, duration)});
               }
           }
       }

       function updateEventHighlight() {
           Array.from(document.getElementsByClassName('highlight')).forEach(function (p) {
               p.classList.remove('highlight');
           });
           var time = parseFloat(player.getCurrentTime());
           var event = findEvent(time, eventDivs);
           if (!event) {
               return;
           }
           event.firstChild.classList.add("highlight");
           //caption.scrollTop = event.offsetTop - eventDivs[0][0].offsetTop;
           smoothScrollTo(event.offsetTop - eventDivs[0][0].offsetTop, Date.now(), 300);
       }

       function initialize() {
           caption = document.getElementById("caption");
           eventDivs = shadamaEvents.map(processOne); // [[div, time]]  As a side-effect it adds divs to caption
       }
       onload = initialize;
  </script>
  </head>
  <body>
    <article>
      <h1 id="title">Shadama: A Particle Simulation<br> Programming Environment for Everyone</h1>
      <p class="subtitle">Yoshiki Ohshima, Dan Amelang and Vanessa Freudenberg<br>
      HARC/Y Combinator Research</p>

      <section id="abstract">
        <p>
We present a prototype of a programming system called Shadama.
Shadama is designed for writing programs that create, control and visualize large numbers of objects.
The basic execution model follows the tradition of StarLogo and its "turtles and patches" abstraction.
<label for="sn-starlogo"
       class="margin-toggle sidenote-number">
</label>
<input type="checkbox"
       id="sn-starlogo"
       class="margin-toggle"/>
<span class="sidenote">
<a href="#starlogo">
<i>Turtles, Termites, and Traffic Jams: Explorations in Massively Parallel Microworlds</i>
<br>
<img src="starlogo-book.jpg" width="50%" height="50%" style="margin-left: 20.2%"/>
</a>
</span>
&nbsp; This abstraction has been proven to be effective and easy to use.
The primary goal of the language is to facilitate the writing of scientific simulations by students
at the high school level.
        </p>

        <p>
The Shadama environment supports <i>liveness</i>.
Once changes to the program are saved, the effect on the running simulation is immediate;
there is no need to restart the simulation.
        </p>
        <p>
Shadama programs are run on the GPU by means of code translation to the OpenGL Shading Language.
<label for="sn-glsl"
       class="margin-toggle sidenote-number">
</label>
<input type="checkbox"
       id="sn-glsl"
       class="margin-toggle"/>
<span class="sidenote">
<a href="#glsl">The OpenGL Shading Language</a>
</span> &nbsp;
Program data resides entirely on the GPU, which enables high performance.
        </p>

        <p>
A prototype of Shadama can be found <a href="http://tinlizzie.org/~ohshima/shadama2">here</a>.
Be aware that Shadama requires WebGL 2 and is affected by the floating point precision provided
by your graphics card. Thus, it only works on certain computer systems.
From our experience, it seems to work better on computers with an AMD Radeon graphics
card and on Chrome or Firefox browsers.
</p>
      </section>
      <section>
        <h2>Introduction</h2>
        <p>
The computing power available to us today is astounding.  Achieving
one teraflop of performance was a milestone for a building-sized supercomputer in
the late '90s, but now we expect smart phones to reach this same milestone soon.
Computing performance will only continue to increase in the future.
        </p>
        <p>
But what are people using this power for?  Not to be critical, but
people are generally more interested in watching cat videos and
playing games than trying to invent self-piloting personal airplanes
or discover the graviton.

All joking aside, one of the big problems we face today is our
struggle to advance science literacy, even within a
technologically-advanced society.  We need the next
generation to embrace science more, not less.
        </p>
        <p>
We think now is a good time to redouble our efforts to provide
environments where students and even professional
programmers can more easily tap into the computing power that is available.
To this end, we have been working on a prototype of a
programming language intended for high school students to explore
scientific concepts.
        </p>
        <p>
  Science is about making the invisible visible.  One notable example
of an invisible yet important concept is molecules in a gas.  We would
like students to learn about this, not by rote memorization, but
through actual experiments and model-building.  With the help of
computers, students can make a dynamic model and understand it more
deeply.  This kind of environment will help students construct
knowledge by doing, in line with the constructivism philosophy of
education.
        </p>
</section>

<section>
        <h2 id="a-science-experiment">A Science Experiment</h2>
        <p>
Before introducing the Shadama programming environment, we first
give an example of a physics experiment that could also be modeled
and simulated on a computer.
</p>
<iframe width="640" height="360" src="https://www.youtube.com/embed/07D0nB3mgLA" frameborder="0" allowfullscreen></iframe>
<p>
This movie demonstrates a vacuum cannon.  The cannon is a six foot PVC
pipe connected to a vacuum pump.  We put a ping pong ball inside the pipe,
cover the ends with sturdy but breakable material (such as plastic plates),
and pump the air out.
        </p>
        <p>
The pump reduces the pressure inside the tube to about 20% of full atmospheric pressure.
        </p>
        <p>
When the end near the ping pong ball is broken open by a box cutter, the
air molecules that rush into the pipe move into the
low pressure space and the ping pong ball is pushed out the other end.
Our crude setup can accelerate the ball to a speed of over 200 meters per second
(about 60% of the speed of sound).  Others have built similar setups
that can achieve supersonic speed.
        </p>
        <p>
An interesting point to understand is that it is just movement of
molecules that is causing the ball to shoot out. It is not that the
vacuum is sucking molecules into the pipe.
</p>
<p>
The invisible molecules that cause the ball to shoot out can
be made &ldquo;visible&rdquo; in a sense not only through this physical experiment,
but also through a computer simulation that reproduces the same phenomenon.
Creating such simulations is the purpose of our programming environment.
          </p>
</section>

<section>
        <h2 id="language-goals">Language Goals</h2>

<p>
We had the following goals when designing Shadama:
<ul>
<li> Easy to learn</li>
<li> Openness</li>
<li> Support for large numbers of particles</li>
<li> Liveness</li>
</ul>
</p>

<p>
To make learning Shadama easy, we based our language on StarLogo,
whose turtles and patches approach has proved intuitive to young learners.
In addition, we expect students familiar with Scratch to
learn Shadama easily because of similarites in how object behavior
is programmed and how objects can sense values near them spatially.
</p>

<p>
To encourage openness, we designed Shadama to be capable of implementing
complex behavior in the language itself, with as few primitives as possible.
We think that a learning environment should be open
in the sense that a student should be able to see, change and understand
how the various parts of the system work.
Although many sophisticated scientific software packages and simulation environments
exist, they are presented as immutable black boxes,
which limits understanding and stifles curiousity.
When additional software support is required, it should be provided in the
end-user's programming language, and it should be capable of modification
within the end-user's environment.
</p>

<p>
To support large numbers of particles, we designed the language
to execute on graphics hardware. Graphics processors today
are capable of computing on massive amounts of data.
Unfortunately, this requires a trade-off between ease of use and
high performance because there are fundamental limitations in
the execution model of today's graphics hardware.
Although Shadama has some features to mitigate these limitations,
certain behaviors cannot be implemented.
</p>

<p>
To support liveness, we designed the Shadama environment to show
the effects of code changes immediately. Of course,
a running simulation should not be updated for each and every key stroke.
Instead, the user submits a batch of code changes for the environment
to apply.
</p>

</section>

<section>
        <h2 id="shadama-in-Action">Shadama in Action</h2>
        <p>
The following movie introduces our prototype programming environment through several examples.
For details on the language, see the appendix.
The script for the narration of the movie is included below.
You can pause the movie at any time to scroll through and read the script.
        </p>
  <div id="video">
    <div id="player"></div>
  </div>
  <div id="caption" class="caption"></div>
  <hr>
</section>
<section>
        <h2 id="implementation">Implementation</h2>
</section>
<p>
Shadama is built on web technologies, including WebGL 2.0 and OpenGL
Shading Language version 3.0.
Our code translator is written in Ohm
<label for="sn-ohm"
       class="margin-toggle sidenote-number">
</label>
<input type="checkbox"
       id="sn-ohm"
       class="margin-toggle"/>
<span class="sidenote">
<a href="#ohm">Ohm: A library and language for building parsers, interpreters, compilers, etc.</a>
</span>
and generates vertex shader, fragment shader and JavaScript code from the Shadama program.
All the values for a given breed and property are stored in a single OpenGL texture.
These textures are created with the OpenGL type "R32F", to match
their use as an array of floating-point scalar values.
The values for a given patch and property are similarly represented.
</p>
<p>
Shadama static functions are translated to Javascript code that
runs OpenGL shaders derived from the Shadama methods.
For each method, a vertex shader is generated to fetch property values
from textures and perform the computation required for that method.
A generated fragment shader stores the property values back
into textures, using the multiple render targets feature of OpenGL.
</p>

<section>
        <h2 id="related-work">Related Work</h2>
        <p>
Previously, one of the authors implemented a particle system called Kedama as an extension of Etoys.
<label for="sn-kedama"
       class="margin-toggle sidenote-number">
</label>
<input type="checkbox"
       id="sn-kedama"
       class="margin-toggle"/>
<span class="sidenote">
<a href="#kedama">
Kedama: A GUI-Based Interactive Massively Parallel Particle Programming System.<br>
<img src="kedama.png" width="50%" height="50%" style="margin-left: 20%" alt="Kedama screenshot" /></a><br>

</span> &nbsp;    Shadama can be considered an attempt to give the same idea new life.
Kedama's target audience was middle school children, while Shadama's target audience is high school students.
        </p>
        <p>
The biggest inspiration for Shadama (and Kedama) was Resnick's StarLogo.
As such, it provided the basis for the basic organization of objects in Shadama.
However, StarLogo has certain features that Shadama does not, as mentioned in the introduction.
        </p>
        <p>
Based on Extempore, Swift et al. created a live programming environment for physics.
<label for="sn-extempore-pic"
       class="margin-toggle sidenote-number">
</label>
<input type="checkbox"
       id="sn-extempore-pic"
       class="margin-toggle"/>
<span class="sidenote">
<a href="#extempore">Live Programming in Scientific Simulation<br>
<img src="extempore-pic.png" width="50%" height="50%" style="margin-left: 20%" alt="Extempore PIC demo screenshot" /></a><br>
</span> &nbsp;
This environment brings dynamic code swapping and interactive data
inspection to a sophisticated and optimized particle-in-cell
simulation engine. The spirit of this work is much in line with ours,
although their environment uses a third-party engine that cannot be modified from this same environment.
This is a reflection of their focus on empowering scientific researchers.
Such users are already familiar with the concepts behind the simulation and
value the tight interaction offered by this approach.
While it is possible to rewrite parts of the third-party engine in Extempore,
this is beyond the ability of most users, especially our target audience.
</p>
<p>
Nicky Case's simulation construction environment represents an interesting point in the design space.
<label for="sn-emoji"
       class="margin-toggle sidenote-number">
</label>
<input type="checkbox"
       id="sn-emoji"
       class="margin-toggle"/>
<span class="sidenote">
<a href="#emoji">Simulating the World (in Emoji)<br>
  <img src="emoji.png" width="50%" height="50%" style="margin-left: 20%" alt="Simulation in Emoji screenshot" /></a>
</span>  &nbsp;
The system features a user-friendly design for creating many types of open-ended models.
However, it is only designed to handle a few hundred particles and cells.
</p>
<p>
Programming the GPU from a high-level language is a hot topic.
<label for="sn-ikra"
       class="margin-toggle sidenote-number">
</label>
<input type="checkbox"
       id="sn-ikra"
       class="margin-toggle"/>
<span class="sidenote">
<a href="#ikra">Object Support in an Array-based GPGPU Extension for Ruby</a>
</span>&nbsp;  Researchers in this area aim for better performance through
increasingly sophisticated compilation techniques and the use of the CUDA API to more directly access the GPU.
Ease of use is given little consideration.
The authors think that Shadama can occupy a unique position
by striking a better balance between performance and ease of use.
        </p>
        <p>
Some languages for programming massively parallel particle simulations
are based on visual programming blocks.
StarLogo Nova is a notable example.
<label for="sn-slnova"
       class="margin-toggle sidenote-number">
</label>
<input type="checkbox"
       id="sn-slnova"
       class="margin-toggle"/>
<span class="sidenote">
<a href="#slnova">
StarLogo Nova: A Programming Environment For Students and Teachers to
Create 3D Games and Simulations for Understanding Complex Systems
</a>
</span>
Shadama is currently text-based because we feel that scientific simulations
can be naturally expressed with concise text.
However, we have not ruled out other possiblities for syntax,
including a visual representation of the program.
        </p>

        <p>
Although many simulation environments such as Liquid Fun
<label for="sn-liquidfun"
       class="margin-toggle sidenote-number">
</label>
<input type="checkbox"
       id="sn-liquidfun"
       class="margin-toggle"/>
<span class="sidenote">
<a href="#liquidfun">LiquidFun: A 2D Rigid-body and Fluid Simulation C++ Library for Games Based Upon Box2D<br>
<img src="liquidfun.png" width="50%" height="50%" style="margin-left: 20%" alt="LiquidFun screenshot" /></a>
</span>
are available today, they do not provide an end-user language.
</p>

</section>

<section>
        <h2 id="conclusions-and-future-work">Conclusions and Future Work</h2>
        <p>
We have presented an early prototype of a language in
which users can make enlightening simulations and intricate visualizations.
The liveliness of the environment encourages an
exploratory style of programming that enables trying out different ideas quickly.
We have also discovered that such an interactive and graphical environment
can be motivating even as bugs appear because of the spectacular
unintentional visual effects that are produced.
        </p>
        <p>
We are considering various improvements to the system.  One major
addition would be to fully support simulations in 3D, not just 2D.
While computation in Shadama only uses scalar values and is agnostic to dimensionality,
the primitives and concepts the system currently provides only work well for 2D applications.
We will need new ideas to manage 3D spatial data.
        </p>
        <p>
We also plan to support more mathematical concepts, such as vectors and matrices.
While first-time users may not initially have use for such abstractions,
we would like them to eventually learn and use these powerful concepts.
Ideally, the environment would gradually introduce the user to new, more difficult approaches.
        </p>
        <p>
We would like to conclude this paper by stressing the importance of
education. Education raises our awareness and enables us to see our world from new perspectives.
In this way, we are empowered with new approaches to solve problems.
For the next generation to solve the challenges of the future, their science literacy
is imperative. Our aim with Shadama is to leverage the power and ubiquity of
computing devices to improve science literacy for high school students by providing an engaging, open
environment in which to explore scientific concepts.
        </p>
</section>

      <section>
        <h2>References</h2>
        <ol type="1">
          <li id="starlogo">
            Mitchel Resnick. <i>Turtles, Termites, and Traffic Jams: Explorations
            in Massively Parallel Microworlds</i>. MIT Press, Cambridge, MA, USA, 1994.
          </li>
          <li id="glsl">
            The OpenGL Shading Language
            (<a href="https://www.khronos.org/registry/OpenGL/index_gl.php">Khronos OpenGL Registry</a>)
          </li>
          <li id="ohm">
            Ohm: A library and language for building parsers, interpreters, compilers, etc.
            (<a href="https://ohmlang.github.io/">project page</a>)
          </li>
          <li id="kedama">
            Yoshiki Ohshima. Kedama: A GUI-based Interactive Massively Parallel Particle Programming System.
            In <i>2005 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC’05)</i>, pages 91–98, Sept 2005.
          </li>
          <li id="extempore">
            Ben Swift, Andrew Sorensen, Henry Gardner, Peter Davis, and Viktor K Decyk.
            Live Programming in Scientific Simulation. <i>Supercomputing Frontiers and Innovations</i>, 2(4):4–15, March 2015.
            (<a href="http://dx.doi.org/10.14529/jsfi150401">DOI</a>)
          </li>
          <li id="liquidfun">
            LiquidFun: A 2D Rigid-body and Fluid Simulation C++ Library for Games Based Upon Box2D
            (<a href="http://google.github.io/liquidfun/">project page</a>)
          </li>
          <li id="emoji">
            Nicky Case. Simulating the World (in Emoji)
            (<a href="http://ncase.me/simulating">project page</a>)
          </li>
          <li id="ikra">
            Matthias Springer and Hidehiko Masuhara. Object Support in an Array-based GPGPU Extension for Ruby.
            In <i>Proceedings of the 3rd ACM SIGPLAN International Workshop on
            Libraries, Languages, and Compilers for Array Programming</i>,
            ARRAY 2016, pages 25–31, New York, NY, USA, 2016.
          </li>
          <li id="slnova">
            StarLogo Nova: A Programming Environment For Students and Teachers to
            Create 3D Games and Simulations for Understanding Complex Systems
            (<a href="http://education.mit.edu/portfolio_page/starlogonova/">project page</a>)
          </li>
        </ol>
      </section>
<section>
        <h2 id="language">Appendix: A Primer for the Shadama Language</h2>

<p>
The Shadama language uses a turtles and patches abstraction, drawn from the tradition of StarLogo.
</p>

        <h3 id="breeds">Breeds</h3>
<p>
Turtles are organized into
"breeds".  Each breed has its own set of properties.
A breed is declared in a program with the "breed" statement.  For example:
</p>
<pre class="code">
breed MyBreed (x, y)
</pre>
<p>
The above creates a breed of turtle called <code>MyBreed</code>, and declares that each
turtle in the breed has individual properties <code>x</code> and <code>y</code>.
</p>
<p>
Currently, properties in Shadama can only be scalar floating-point numbers.
</p>
<p>
Methods provide turtle behavior. The <code>def</code> statement is used to define
methods, as follows:
</p>
<pre class="code">
def move() {
  this.x = this.x + 1;
  this.y = this.y + 1;
}
</pre>
<p>
As expected, when this method is invoked on a turtle, the
turtle's x and y properties are incremented by one.
</p>
<p>
Methods can only be invoked from static functions. Methods calls are made
by first specifying a breed, then the method name.
The method is applied to all turtles in the breed concurrently.
For example:
</p>
<pre class="code">
static step() {
  MyBreed.move();
}
</pre>
<p>
The <code>step</code> function above calls the <code>move</code> method on all turtles of the <code>MyBreed</code> breed.
</p>

<p>
Shadama provides many built-in features made available through primitive methods:
</p>
<ul>

<li> <pre class="primitive">aBreed.setCount(count);</pre>
  <span>
  The <code>setCount</code> primitive sets the number of turtles in the breed.
For example:
</span>
<pre class="code">
static setup() {
  MyBreed.setCount(10000);
}
</pre>
<span>
Invoking this static function will set the number of <code>MyBreed</code> turtles to 10,000.
In the current implementation, the number of turtles in a breed is limited to
1024 × 1024, or about 1 million.
</span>
</li>

<li> <pre class="primitive">aBreed.fillRandom(name, min, max);</pre>
<span>
  The <code>fillRandom</code> primitive sets the property specified by <code>name</code>
  to be a random number between <code>min</code>
  (inclusive) and <code>max</code> (exclusive) for each turtle in the breed.
  For example:
</span>
<pre class="code">
static setup() {
  MyBreed.setCount(10000);
  MyBreed.fillRandom("x", 0, 100);
}
</pre>
<span>
  The above will set each of the 10,000 turtles <code>x</code> property to be a
  random floating-point number between 0 and 100.
</span>
</li>

<li> <pre class="primitive">aBreed.fillRandomDir(dxName, dyName);</pre>
<span>
  The <code>fillRandomDir</code> primitive generates random 2D unit vectors.
  This is done for each turtle, and the x and y components of the result are stored
  in the <code>dxName</code> and <code>dyName</code> properties of the turtles.
  For example:
</span>
<pre class="code">
static setup() {
  MyBreed.setCount(10000);
  MyBreed.fillRandomDir("dx", "dy");
}
</pre>
<span>
The above sets the <code>dx</code> and <code>dy</code> properties of the turtles with the x and y components of the randomly generated unit vectors.
</span>
</li>

<li> <pre class="primitive">aBreed.fillSpace(xName, yName, xDim, yDim);</pre>
        <span>
The fillSpace primitive first sets the number of turtles in the breed
to be <code>xDim</code> × <code>yDim</code>.  Then, it places the turtles on integral 2D grid points
within the (0..<code>xDim</code>, 0..<code>yDim</code>) area, storing into the <code>xName</code> and <code>yName</code> turtle properties.
For example:
</span>
<pre class="code">
static setup() {
  MyBreed.fillSpace("x", "y", 100, 100);
}
</pre>
<span>
The above creates 10,000 turtles of the MyBreed breed, setting the turtle's <code>x</code> and <code>y</code> properties
to be the integral grid points spanning (0, 0) to (99, 99), inclusive.
</span>
</li>

<li> <pre class="primitive">aBreed.fillImage(xName, yName, rName, gName, bName, aName, anImageData);</pre>
        <span>
  The fillImage primitive converts a 2D image into a breed of turtles.
  The <code>anImageData</code> argument is a Javascript ImageData object containing the data used
  to populate the breed. The turtle count is set to be <code>anImageData.width</code> × <code>anImageData.height</code>.
  Similar to <code>fillSpace</code>, the turtles are placed on the 2D grid points within the image extent.
  The turtle properties given by <code>rName</code>, <code>gName</code>, <code>bName</code>, and <code>aName</code> are populated with the RGBA
  color component values of the image. Note that while the color components in <code>anImageData</code> range
  from 0 and 255 (integral values), those values in Shadama will be normalized to range from 0.0 and 1.0,
  inclusive (floating-point).
  For example:
<pre class="code">
breed MyBreed (x, y, r, g, b, a)
static setup() {
  MyBreed.fillImage("x", "y", "r", "g", "b", "a", anImage);
}
</pre>
</span>
<span>
Static function variables, such as <code>anImage</code>, are described below.
</span>
</ul>

<h3 id="patches">Patches</h3>

<p>
A patch is a 2D set of cells that store values.
Patches are fixed size, 512 × 512 by default.
The following declares a patch:
<pre class="code">
patch Field (nx, ny)
</pre>
</p>
<p>
Each cell in this patch stores two values, <code>nx</code> and <code>ny</code>.
</p>

<p>
A patch can be manipulated by passing it as an argument to a method on a breed.
As the method is executed for each turtle, turtles can access the patch cell
nearest them. No other patch cells are available to them.
For example:
<pre class="code">
breed MyBreed (x, y, r, g, b, a)
patch Field (r, g, b, a)

def store(field) {
  field.r = this.r;
}

static setup() {
  MyBreed.fillImage("x", "y", "r", "g", "b", "a", anImage);
  MyBreed.store(Field);
}
</pre>
</p>
<p>
The above declares a patch called Field which is used as an argument to <code>store</code>.
When <code>store</code> is executed for each turtle in <code>MyBreed</code>, the turtle's <code>r</code> property
is stored in the <code>r</code> property of the nearest cell in Field.
</p>

<p>
A turtle can read values from patch cells as well.  For example:
<pre class="code">
def load(field) {
   this.r = field.r;
}
</pre>
</p>
<p>
When the above method is executed, each turtle reads the <code>r</code> property of the nearest patch cell
and stores the value into its own <code>r</code> property.
</p>
<p>
Methods can receive multiple patches as arguments.
For example:
<pre class="code">
patch Field1 (nx, ny, r, g, b, a)
patch Field2 (nx, ny, r, g, b, a)
def transfer(f1, f2) {
  f2.r = f1.r;
  f2.a = f1.a;
}
</pre>
</p>
<p>
The following code is also valid, and correctly swaps values between patches.
<pre class="code">
def swap(f1, f2) {
  f2.r = f1.r;
  f1.r = f2.r
}
</pre>
</p>

<h3 id="local-variables">Local Variables</h3>

<p>
The <code>var</code> statement declares a local variable within a method.
The scope of a local variables is the whole method,
regardless of where in the method it is declared.
In the same method, there can be no more than one declaration for a given variable name.
This is in contrast to variable declarations in JavaScript.
For example:
<pre class="code">
def average() {
  var avg = (this.x + this.y) / 2.0;
  this.x = avg;
  this.y = avg;
}
</pre>
<p>
The above code properly defines and uses a local variable called <code>avg</code>.
However, the following code would raise an error because the variable <code>diff</code> is declared in two places:
<pre class="code">
def gcd() {
  if (this.a > this.b) {
    var diff = this.a - this.b;
    this.a = diff;
  } else {
    var diff = this.b - this.a;
    this.b = diff;
  }
</pre>
</p>
<p>
The variable declaration has to be manually hoisted, as follows:
<pre class="code">
def gcd() {
  var diff;
  if (this.a > this.b) {
    diff = this.a - this.b;
    this.a = diff;
  } else {
    diff = this.b - this.a;
    this.b = diff;
  }
</pre>
</p>

<h3 id="static-function-variables">Static Function Variables</h3>

<p>
Static function variables are declared within static functions, also using the "var" statement.
Static function variables are not available to methods, but are visible to all static functions.
For example:
<pre class="code">
static setup() {
  var begin = 1;
}

static loop() {
  if (begin) {
    begin = 0;
  }
}
</pre>
</p>
<p>
The two static functions above refer to the same <code>begin</code> variable.
</p>

<p>
Shadama provides the following built-in static function variables:
<ul>
  <li>
    <code>mousemove</code>:
    An object whose <code>x</code> and <code>y</code> properties refer to the most recent mouse cursor location.
  </li>
  <li>
    <code>mousedown</code>:
    An object whose <code>x</code> and <code>y</code> properties refer to the most
    recent location where the user pressed the mouse button down.
  </li>
  <li>
    <code>mouseup</code>:
    An object whose <code>x</code> and <code>y</code> properties refer to the most
    recent location where the user lifted the mouse button up.
  </li>
  <li>
    <code>time</code>:
    The number of seconds elapsed since the last time the <code>setup</code> function was called (in floating-point).
  </li>
  <li>
    <code>width, height</code>:
    The width and height of the Shadama canvas.
  </li>
</ul>

<p>
Be aware that mouse event objects are JavaScript objects. Thus, they can't be passed to methods because
methods can only take scalar arguments.
</p>

<p>
There is one additional variable called <code>Display</code>
for invoking certain system primitives.

For example:
<pre class="code">
static loop() {
  Display.clear();
  MyPatch.draw();
}
</pre>
<p>
The above code clears the canvas and then draws <code>MyPatch</code> by calling the <code>draw</code> primitive.  <code>Display</code> has <code>loadProgram</code>, and <code>clear</code>.
</p>

<h3 id="parallelism-considerations">Parallelism Considerations</h3>
<p>
It's possible for two or more nearby turtles to write into the same patch cell.
Which value gets stored in the patch is non-deterministic.
</p>
<p>
Also, updates to turtle properties and patch properties are not visible until after the method is run.
Consider the following method:
<pre class="code">
def test() {
  if (this.r > 0) {
     this.r = 0;
  } else {
     this.r = 1;
  }
  this.b = this.r;
}
</pre>
</p>
<p>
Even though the last line reads <code>this.b = this.r;</code>, the <code>r</code> property and <code>b</code> property will
not be equal after the invocation. This is because the update to the <code>r</code> property seen earlier does not take effect
until after the method call is finished. Thus, the <code>b</code> property will have the previous <code>r</code> value.
</p>

<p>
The properties <code>this.b</code> and <code>this.r</code> can have the same value
through the following use of a local variable:
<pre class="code">
def test() {
  var r = this.r;
  if (r > 0) {
     r = 0;
  } else {
     r = 1;
  }
  this.r = r;
  this.b = r;
}
</pre>
</p>

<p>
A script can be started by calling <code>start</code> on it. Likewise, you can stop it <code>stop</code>, and execute it once with <code>step</code>.
</p>

<h3 id="control-structures">Control Structures</h3>
<p>
The <code>if</code> statement is the only control structure that Shadama supports.
Loops may be supported in a future version of Shadama because the OpenGL shader language version 3.0
does support variable-count loops.
</p>
<p>

<h3 id="primitive-functions">Primitive Functions</h3>
<p>

There are a number of primitive functions that can be called from methods.
Most of them actually result in a direct call to a GLSL built-in function.
For example:
<pre class="code">
def prims(x) {
  var c = cos(x);
  var s = step(0.5, x);
  var a = abs(x);
  var f = fract(x); // the fraction part of x

  this.r = c * s * a * f;
}
</pre>
</p>
<p>
The above code uses several primitive functions to compute a contrived value which
is then stored into the turtle's <code>r</code> property.
</p>

<h3 id="method-binding">Method Binding</h3>
<p>
Methods are not defined for any particular breed, but a given
method can only be applied to breeds that have the properties referenced
in the method.
For example:
<pre class="code">
breed A (x, r)
breed B (x, y, r, g)
breed C (r)

def set() {
  this.r = 1;
  this.x = 0;
}

static test() {
  A.set();
  B.set();
}
</pre>
</p>
<p>
The <code>set</code> method above can be called for both breed <code>A</code> and breed <code>B</code>.
This is the not the case for breed C because it does not have an <code>x</code> property, which is
referenced in <code>set</code>.
</p>

<h3 id="limitations">Limitations</h3>

<p>
The following are important limitations of the Shadama language.
</p>

<p>
Methods can not take breeds as arguments.
For example, the following code is invalid:
<pre class="code">
breed A (x, y)
breed B (x, y)

def hit(other) {
  var diff = other.x - this.x;
  ...
}

static step() {
  A.hit(B);
}
</pre>
</p>

<p>
The <code>step</code> function passes breed B as an argument to the <code>hit</code> method, which is not allowed.
Even if it were, it is not clear which turtle from breed <code>B</code> should
be bound to the argument <code>other</code>.
</p>

<p>
Another limitation is that a given method can either update the turtle's properties or
the patch's properties, but not both.
For example, the following code is invalid:
<pre class="code">
def test(field) {
  field.r = 1;
  this.r = 1;
}
</pre>
</p>

<p>
This limitation arises from limitations in WebGL itself. Future
versions of WebGL, and thus Shadama, may no longer have this restriction.
In the meantime, a workaround is to split the method into two methods &mdash; one
for updating the patch and one for updating the turtle.
It is also possible that a future version of Shadama will automatically
perform this code transformation.
</p>

</section>

    </article>
  </body>
</html>
